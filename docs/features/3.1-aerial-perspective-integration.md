# 3.1: Aerial Perspective Integration

## Dependencies
- 2.1-2.4: Complete transmittance and multi-scatter LUTs ✓
- Existing terrain shader system
- UniformManager (existing)
- Backend uniform packing system

## Scope
Integrate aerial perspective into existing terrain fragment shaders. Apply atmospheric scattering to terrain based on distance and altitude, creating realistic haze and atmospheric color.

## Current State
- LUTs are computed and available
- Terrain shaders exist in both WebGPU/WebGL2
- UniformManager can hold new uniforms
- Backend packs uniforms into buffers (WebGPU) or sets them (WebGL2)

## Architecture Integration
```
Frontend.render()
  ├─> Update atmospheric uniforms in UniformManager
  │     └─> uniformManager.updateAtmosphericParams()
  │
  └─> Render terrain (existing)
        ├─> Backend packs uniforms (includes new atmospheric params)
        ├─> Bind transmittance LUT texture
        └─> Execute terrain shaders (now with aerial perspective)
```

## What Needs to Happen

### 1. Add Atmospheric Uniforms to UniformManager

In `UniformManager.js`:

Add properties:
```javascript
this.atmosphericParams = {
    planetRadius: 6360000,
    atmosphereRadius: 6460000,
    viewerAltitude: 0,
    sunDirection: { x: 0, y: 0.7071, z: 0.7071 },
    rayleighScattering: { r: 5.5e-6, g: 13.0e-6, b: 22.4e-6 },
    mieScattering: 21e-6,
    mieAnisotropy: 0.758,
    rayleighScaleHeight: 8000,
    mieScaleHeight: 1200
};
```

Add update method:
```javascript
updateAtmosphericParams(settings, camera, sunDir) {
    // Copy from settings to this.atmosphericParams
    // Update viewerAltitude from camera.position.z
    // Update sunDirection from environmentState
}
```

### 2. Pack Atmospheric Uniforms in Backend

#### In WebGPUBackend._packFragmentUniforms()

Add after existing uniforms (maintain 16-byte alignment):
```
// Atmospheric parameters (64 bytes total)
planetRadius: f32
atmosphereRadius: f32
viewerAltitude: f32
padding: f32

sunDirection: vec3<f32>
padding: f32

rayleighScattering: vec3<f32>
rayleighScaleHeight: f32

mieScattering: f32
mieAnisotropy: f32
mieScaleHeight: f32
padding: f32
```

Pack values from `uniformManager.atmosphericParams`.

#### In WebGL2Backend

Add uniform setting in terrain material setup:
```javascript
gl.uniform1f(loc_planetRadius, uniformManager.atmosphericParams.planetRadius);
gl.uniform1f(loc_atmosphereRadius, uniformManager.atmosphericParams.atmosphereRadius);
// ... etc
```

### 3. Update Terrain Shader Structs

#### WebGPU: `shaders/webgpu/terrain.wgsl`

Add to `FragmentUniforms` struct:
```wgsl
struct FragmentUniforms {
    // ... existing fields ...
    
    // Atmospheric parameters
    planetRadius: f32,
    atmosphereRadius: f32,
    viewerAltitude: f32,
    _pad0: f32,
    
    sunDirection: vec3<f32>,
    _pad1: f32,
    
    rayleighScattering: vec3<f32>,
    rayleighScaleHeight: f32,
    
    mieScattering: f32,
    mieAnisotropy: f32,
    mieScaleHeight: f32,
    _pad2: f32,
}
```

#### WebGL2: `shaders/webgl2/terrain.glsl`

Add uniforms:
```glsl
uniform float planetRadius;
uniform float atmosphereRadius;
uniform float viewerAltitude;
uniform vec3 sunDirection;
uniform vec3 rayleighScattering;
uniform float rayleighScaleHeight;
uniform float mieScattering;
uniform float mieAnisotropy;
uniform float mieScaleHeight;
```

### 4. Bind Transmittance LUT to Terrain Material

The terrain material needs access to the transmittance LUT texture.

#### WebGPU
Add texture binding to terrain bind group (or create new bind group):
- Binding: transmittanceLUT texture
- Binding: transmittance sampler (linear, clamp)

#### WebGL2
Bind to texture unit (e.g., unit 7):
```javascript
gl.activeTexture(gl.TEXTURE7);
gl.bindTexture(gl.TEXTURE_2D, transmittanceLUT);
gl.uniform1i(loc_transmittanceLUT, 7);
```

### 5. Add Aerial Perspective Functions to Terrain Shaders

Create utility file or add to terrain shader:

**Key Functions Needed:**

1. **LUT UV Mapping:**
```wgsl
   fn altitudeAndCosAngleToUV(altitude: f32, cosAngle: f32) -> vec2<f32>
```

2. **Sample Transmittance LUT:**
```wgsl
   fn sampleTransmittanceLUT(altitude: f32, cosViewZenith: f32) -> vec3<f32>
```

3. **Phase Functions:**
```wgsl
   fn rayleighPhase(cosTheta: f32) -> f32
   fn miePhase(cosTheta: f32, g: f32) -> f32
```

4. **Inscatter Computation:**
```wgsl
   fn computeInscatter(distance: f32, viewDir: vec3<f32>, sunDir: vec3<f32>) -> vec3<f32>
```

5. **Apply Aerial Perspective:**
```wgsl
   fn applyAerialPerspective(terrainColor: vec3<f32>, worldPos: vec3<f32>) -> vec3<f32>
```

### 6. Integrate into Terrain Fragment Shader

At the end of existing terrain fragment shader:
```wgsl
@fragment
fn fs_main(input: VertexOutput) -> @location(0) vec4<f32> {
    // ... existing terrain shading code ...
    // Results in: let terrainColor = ...
    
    // Apply aerial perspective
    let finalColor = applyAerialPerspective(terrainColor, input.worldPos);
    
    return vec4<f32>(finalColor, 1.0);
}
```

Don't replace existing shading - add this as final post-process.

### 7. Update Frontend Render Loop

In `Frontend.render()`:
```javascript
async render(gameState, environmentState, deltaTime) {
    // ... existing code ...
    
    // Update atmospheric uniforms
    const sunDir = this.calculateSunDirection(environmentState);
    this.uniformManager.updateAtmosphericParams(
        this.atmosphereSettings,
        this.camera,
        sunDir
    );
    
    // ... rest of render ...
}
```

Add sun direction calculation:
```javascript
calculateSunDirection(environmentState) {
    const sunAngle = environmentState.timeOfDay * Math.PI * 2;
    return {
        x: Math.cos(sunAngle),
        y: 0,
        z: Math.sin(sunAngle)
    };
}
```

## Algorithm Details

### LUT Sampling
```
uv.x = cosViewZenith * 0.5 + 0.5
uv.y = sqrt(altitude / atmosphereHeight)
transmittance = texture.sample(uv)
```

### Inscatter Approximation
For performance, use simplified inscatter:
```
rayleighDensity = exp(-altitude / H_rayleigh)
mieDensity = exp(-altitude / H_mie)

scattering = rayleighScattering * rayleighDensity * rayleighPhase(cosTheta) +
             mieScattering * mieDensity * miePhase(cosTheta, g)

opticalDepth = distance * scattering
inscatter = scattering * (1 - exp(-opticalDepth))
```

### Final Blend
```
finalColor = terrainColor * transmittance + inscatter
```

## Files to Modify

- `js/rendering/UniformManager.js` - Add atmospheric uniforms
- `js/rendering/backends/WebGPUBackend.js` - Pack atmospheric uniforms
- `js/rendering/backends/WebGL2Backend.js` - Set atmospheric uniforms
- `js/rendering/shaders/webgpu/terrain.wgsl` - Add aerial perspective
- `js/rendering/shaders/webgl2/terrain.glsl` - Add aerial perspective
- `js/rendering/Frontend.js` - Update uniforms each frame

## Test Criteria

### Visual
- [ ] Distant terrain (> 5km) appears hazier/bluer
- [ ] Nearby terrain (< 1km) mostly unaffected
- [ ] Smooth transition, no seams between chunks
- [ ] Sky color influences distant terrain
- [ ] Looking at horizon: terrain fades to sky color
- [ ] Looking down: minimal atmospheric effect

### Console Checks
- [ ] No shader compilation errors
- [ ] Log: `"Aerial perspective enabled"` (optional)
- [ ] Atmospheric uniforms updating each frame

### Functional
- [ ] Transmittance LUT bound correctly to terrain shader
- [ ] LUT sampling uses correct UV coordinates
- [ ] Formula: `finalColor = terrainColor * transmittance + inscatter`
- [ ] Both WebGPU and WebGL2 produce similar results

### Performance
- [ ] FPS remains 60
- [ ] LUT sampling adds < 0.1ms per frame
- [ ] No overdraw or redundant calculations

### Altitude Tests
Move camera to different altitudes:
- [ ] 100m: Moderate haze at distance
- [ ] 1km: Less haze, clearer view
- [ ] 5km: Minimal haze, very clear
- [ ] Effect diminishes with altitude (correct!)

## Debug Commands
```javascript
window.toggleAerialPerspective = () => {
    window.frontend.useAerialPerspective = !window.frontend.useAerialPerspective;
    console.log(`Aerial perspective: ${window.frontend.useAerialPerspective}`);
};

window.logAtmosphericParams = () => {
    console.log('Atmospheric uniforms:', window.frontend.uniformManager.atmosphericParams);
};

window.testAerialPerspectiveAtAltitudes = () => {
    const altitudes = [100, 1000, 5000, 10000];
    altitudes.forEach(alt => {
        window.camera.position.z = alt;
        window.gameEngine.render();
        console.log(`Rendered at ${alt}m altitude`);
    });
};
```

## Common Issues

**Issue:** No visible effect
- Check transmittance LUT is bound to correct texture unit/binding
- Verify atmospheric uniforms are updating
- Check altitude value is non-zero
- Verify sun direction is normalized

**Issue:** Too much haze near camera
- Check distance calculation (should be world-space distance)
- Reduce scattering coefficients by 0.5x
- Verify viewer altitude is correct

**Issue:** Harsh transition
- Use linear filtering on LUT sampler
- Increase LUT resolution if needed (256×64 should be enough)
- Check no clamping issues at LUT edges

**Issue:** Wrong colors
- Verify Rayleigh scattering favors blue (higher for blue wavelength)
- Check sun direction is correct
- Verify phase functions normalized correctly

**Issue:** Shader binding errors (WebGPU)
- Check bind group layout includes LUT texture
- Verify binding numbers don't conflict
- Ensure sampler is created and bound

## Next Step
After passing all tests, proceed to: **3.2-altitude-fog.md**