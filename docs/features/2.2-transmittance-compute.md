# 2.2: Transmittance Computation

## Dependencies
- 2.1: Transmittance LUT Resources ✓ (must be complete)
- Backend compute shader support (WebGPU) or FBO rendering (WebGL2)

## Scope
Implement ray marching to compute atmospheric transmittance values and write to the LUT texture created in 2.1. This is a one-time computation (unless planet changes).

## Current State
- Transmittance LUT texture exists (256×64 RGBA16F)
- Backend can execute compute shaders (WebGPU) or render to texture (WebGL2)
- Shader files may need to be created in backend-specific directories

## Architecture Integration
```
Frontend.initialize()
  └─> AtmosphericScatteringLUT.compute()
        ├─> WebGPUBackend.computeTransmittance() [if WebGPU]
        │     ├─> Compile compute shader
        │     ├─> Create compute pipeline
        │     ├─> Dispatch workgroups: (32, 8, 1)
        │     └─> Write to transmittanceLUT texture
        │
        └─> WebGL2Backend.computeTransmittance() [if WebGL2]
              ├─> Compile fragment shader
              ├─> Create FBO with transmittanceLUT attached
              ├─> Render fullscreen quad
              └─> Texture contains result
```

## What Needs to Happen

### 1. Add Computation Logic to AtmosphericScatteringLUT

The `compute()` method should:
- Check if dirty flag is set
- Measure computation time
- Delegate to backend-specific method
- Update state flags (isComputed, isDirty)
- Log completion time

### 2. Implement Backend Methods

#### In WebGPUBackend
Add method: `computeTransmittanceLUT(texture, atmosphereSettings)`

Should:
- Compile compute shader from `shaders/webgpu/transmittanceLUT.wgsl`
- Create compute pipeline (cache it for reuse)
- Create bind group with output texture and uniforms
- Dispatch (32, 8, 1) workgroups for 256×64 texture
- Return after compute completes

#### In WebGL2Backend
Add method: `computeTransmittanceLUT(texture, atmosphereSettings)`

Should:
- Compile fragment shader from `shaders/webgl2/transmittanceLUT.glsl`
- Create framebuffer with transmittanceLUT as color attachment
- Set uniforms (atmosphere parameters)
- Render fullscreen quad
- Unbind framebuffer
- Result stays in texture (no readback needed)

### 3. Create Compute Shaders

#### WebGPU Shader
Location: `js/rendering/shaders/webgpu/transmittanceLUT.wgsl`

Structure:
- `@compute` entry point with `@workgroup_size(8, 8, 1)`
- Bind group 0: Output texture (storage), atmosphere params (uniform)
- Each thread computes one pixel of the LUT

#### WebGL2 Shader
Location: `js/rendering/shaders/webgl2/transmittanceLUT.glsl`

Structure:
- Fragment shader
- Input: UV from vertex shader
- Uniforms: Atmosphere parameters
- Output: fragColor = transmittance RGB

## Algorithm Overview

For each pixel (u, v) in the LUT:

1. **Convert UV to physical space:**
```
   altitude = (v * v) * (atmosphereRadius - planetRadius)
   cosViewZenith = u * 2.0 - 1.0
```

2. **Set up ray:**
```
   origin = (0, 0, planetRadius + altitude)
   direction = from origin at angle cosViewZenith
```

3. **Ray-march through atmosphere:**
   - Find intersection with atmosphere sphere
   - March 64 steps from altitude to atmosphere top
   - At each step:
     - Calculate altitude at sample point
     - Compute extinction = Rayleigh + Mie + Ozone densities
     - Accumulate: `opticalDepth += extinction * stepSize`

4. **Compute transmittance:**
```
   transmittance = exp(-opticalDepth)
```

5. **Write to texture:**
   - RGB = transmittance (wavelength-dependent)
   - A = 1.0

## Key Formulas

### Extinction Coefficient
```
σ(h) = σ_rayleigh * exp(-h / H_rayleigh) + 
       σ_mie * exp(-h / H_mie) + 
       σ_ozone * ozone_distribution(h)
```

Where:
- `H_rayleigh` ≈ 8000m (scale height)
- `H_mie` ≈ 1200m (scale height)
- Ozone peaks around 25km

### Ozone Distribution
```
ozone(h) = max(0, 1 - abs(h - 25000) / 15000)
```

### Ray-Sphere Intersection
Solve: `|origin + t * direction|² = radius²`

Returns (t_near, t_far) or (-1, -1) if no intersection.

## Shader Inputs (Uniforms)

Both backends need these parameters:
- `planetRadius: float` (e.g., 6360000 for Earth)
- `atmosphereRadius: float` (e.g., 6460000)
- `rayleighScattering: vec3` (e.g., 5.5e-6, 13.0e-6, 22.4e-6)
- `rayleighScaleHeight: float` (e.g., 8000)
- `mieScattering: float` (e.g., 21e-6)
- `mieScaleHeight: float` (e.g., 1200)
- `ozoneAbsorption: vec3` (e.g., 0.65e-6, 1.88e-6, 0.085e-6)

Pass from `PlanetAtmosphereSettings` to shader.

## Files to Create

- `js/rendering/shaders/webgpu/transmittanceLUT.wgsl`
- `js/rendering/shaders/webgl2/transmittanceLUT.glsl`

## Files to Modify

- `js/atmosphere/AtmosphericScatteringLUT.js` - Add `compute()` method
- `js/rendering/backends/WebGPUBackend.js` - Add `computeTransmittanceLUT()`
- `js/rendering/backends/WebGL2Backend.js` - Add `computeTransmittanceLUT()`

## Expected Visual Result

Debug visualization of the LUT should show:
- **Gradient from blue to orange/red**
- Bottom (low altitude): Darker blue
- Top (high altitude): Lighter, shifting to orange at horizon angles
- Smooth transitions, no banding
- NOT pure black or pure white anywhere

Reference: Bruneton's atmospheric scattering LUT images.

## Performance Targets

- WebGPU: < 10ms for compute pass
- WebGL2: < 15ms for fullscreen render
- Total with overhead: < 16ms (60fps maintained)
- 64 ray march samples sufficient (don't need more)

## Integration in Frontend

In `Frontend.initialize()`:
```javascript
this.atmosphereLUT = new AtmosphericScatteringLUT(this.backend);
await this.atmosphereLUT.initialize();
await this.atmosphereLUT.compute(this.atmosphereSettings); // Add this
```

## Test Criteria

### Visual
- [ ] LUT texture shows gradient (not black/white)
- [ ] Blue at low altitude, orange/red at high
- [ ] Diagonal gradient visible (horizon transition)
- [ ] No banding artifacts

### Console Checks
- [ ] Log: `"Transmittance LUT computed in {X}ms"`
- [ ] No shader compilation errors
- [ ] Computation time < 16ms
- [ ] Backend logs confirm execution

### Functional
- [ ] Compute shader/FBO executes without errors
- [ ] Output texture contains non-zero values
- [ ] Both WebGPU and WebGL2 produce similar results
- [ ] Texture data is RGB transmittance in [0, 1] range

### Performance
- [ ] WebGPU compute: < 10ms
- [ ] WebGL2 render: < 15ms
- [ ] No FPS drop during computation
- [ ] Pipeline/shader compilation cached (fast on re-run)

## Debug Commands
```javascript
window.computeLUT = async () => {
    console.log('=== Computing Transmittance LUT ===');
    const start = performance.now();
    await window.frontend.atmosphereLUT.compute(window.frontend.atmosphereSettings);
    const elapsed = performance.now() - start;
    console.log(`Completed in ${elapsed.toFixed(2)}ms`);
};

// Add debug visualization (optional for step 2.2)
window.visualizeLUT = () => {
    // Render LUT texture to screen quad at (10, 10)
    // Shows 256x64 texture enlarged
};
```

## Common Issues & Solutions

**Issue:** All black texture
- Check ray-sphere intersection returns valid range
- Verify atmosphere radius > planet radius
- Check extinction coefficients are positive

**Issue:** All white texture
- Check optical depth not going negative
- Verify step size (dt) is reasonable
- Check exp() not overflowing

**Issue:** Banding/posterization
- Verify texture format is 16-bit float (not 8-bit)
- Check shader uses enough precision (highp in GLSL)

**Issue:** Shader compilation errors
- Check workgroup size divides texture dimensions evenly
- Verify all uniforms have correct types
- Check WebGPU binding numbers don't conflict

## Next Step
After verification passes, proceed to: **2.3-multiscatter-lut.md**