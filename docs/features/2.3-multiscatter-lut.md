# 2.3: Multi-Scattering LUT

## Dependencies
- 2.1: Transmittance LUT Resources ✓
- 2.2: Transmittance Computation ✓

## Scope
Compute second-order scattering approximation to add realistic sky brightening. Accounts for light scattering multiple times through the atmosphere.

## Current State
- Transmittance LUT is computed and working
- Backend has compute/render-to-texture capability
- Multi-scatter LUT texture may already be created in 2.1

## Architecture Integration
```
AtmosphericScatteringLUT.compute()
  ├─> Backend.computeTransmittanceLUT() [step 2.2]
  └─> Backend.computeMultiScatterLUT()   [this step]
        ├─> Read from transmittanceLUT
        ├─> Compute second-order scattering
        └─> Write to multiScatterLUT (32×32)
```

## What Needs to Happen

### 1. Create Multi-Scatter LUT Texture (if not done in 2.1)

In `AtmosphericScatteringLUT.initialize()`:
- Create 32×32 RGBA16F texture
- Same format as transmittance LUT
- Memory: ~8 KB (much smaller)

### 2. Implement Backend Methods

#### In WebGPUBackend
Add method: `computeMultiScatterLUT(outputTexture, transmittanceLUT, atmosphereSettings)`

Should:
- Compile compute shader from `shaders/webgpu/multiScatterLUT.wgsl`
- Create pipeline (cache for reuse)
- Bind transmittanceLUT for reading
- Bind multiScatterLUT for writing
- Dispatch (4, 4, 1) workgroups for 32×32 texture
- Return after completion

#### In WebGL2Backend
Add method: `computeMultiScatterLUT(outputTexture, transmittanceLUT, atmosphereSettings)`

Should:
- Compile fragment shader from `shaders/webgl2/multiScatterLUT.glsl`
- Create FBO with multiScatterLUT attached
- Bind transmittanceLUT as input texture
- Set uniforms
- Render fullscreen quad
- Result stays in multiScatterLUT

### 3. Create Compute Shaders

#### WebGPU Shader
Location: `js/rendering/shaders/webgpu/multiScatterLUT.wgsl`

Bindings needed:
- Group 0, Binding 0: Output texture (storage write)
- Group 0, Binding 1: Transmittance LUT (texture read)
- Group 0, Binding 2: Sampler (linear filtering)
- Group 0, Binding 3: Atmosphere params (uniform)

#### WebGL2 Shader
Location: `js/rendering/shaders/webgl2/multiScatterLUT.glsl`

Uniforms needed:
- `sampler2D transmittanceLUT`
- Atmosphere parameters (same as transmittance shader)

### 4. Update AtmosphericScatteringLUT.compute()

Should now compute both LUTs:
```javascript
async compute(atmosphereSettings) {
    if (!this.needsRecompute(atmosphereSettings)) return;
    
    await this.backend.computeTransmittanceLUT(
        this.transmittanceLUT,
        atmosphereSettings
    );
    
    await this.backend.computeMultiScatterLUT(
        this.multiScatterLUT,
        this.transmittanceLUT,
        atmosphereSettings
    );
    
    // Update state...
}
```

## Algorithm Overview

Multi-scattering approximates higher-order bounces:

For each pixel (u, v) in 32×32 LUT:

1. **UV to physical space:**
```
   altitude = v * (atmosphereRadius - planetRadius)
   cosSunZenith = u * 2.0 - 1.0
```

2. **Compute scattering coefficient at altitude:**
```
   rayleighDensity = exp(-altitude / H_rayleigh)
   mieDensity = exp(-altitude / H_mie)
   scattering = σ_rayleigh * rayleighDensity + σ_mie * mieDensity
```

3. **Integrate over viewing angles (16-32 samples):**
   For each view angle θ:
   - Sample transmittanceLUT(altitude, cos(θ))
   - Compute phase function contribution
   - Accumulate weighted by solid angle

4. **Store result:**
   - RGB = multi-scatter contribution
   - Typically small values (< 0.5)

## Key Formulas

### Phase Functions

**Rayleigh:**
```
P_rayleigh(θ) = 3/(16π) * (1 + cos²(θ))
```

**Mie (Henyey-Greenstein):**
```
P_mie(θ, g) = (1/(4π)) * (1 - g²) / (1 + g² - 2g*cos(θ))^(3/2)
```

Where g ≈ 0.758 (anisotropy parameter).

### Integration
```
L_ms = ∫ phase(θ) * transmittance(θ) * scattering * sin(θ) dθ
```

Approximated with Riemann sum over 16 angle samples.

## Shader Inputs

Same parameters as transmittance computation, plus:
- Access to transmittanceLUT for reading
- May need sun zenith angle stored per pixel

## Files to Create

- `js/rendering/shaders/webgpu/multiScatterLUT.wgsl`
- `js/rendering/shaders/webgl2/multiScatterLUT.glsl`

## Files to Modify

- `js/atmosphere/AtmosphericScatteringLUT.js` - Update `compute()` method
- `js/rendering/backends/WebGPUBackend.js` - Add `computeMultiScatterLUT()`
- `js/rendering/backends/WebGL2Backend.js` - Add `computeMultiScatterLUT()`

## Expected Visual Result

Multi-scatter LUT should show:
- Subtle color variations across 32×32 grid
- Generally low values (< 0.5)
- Brighter near horizon angles
- Smooth gradients

When integrated (step 3.1):
- Overall scene 10-20% brighter
- Sky appears richer, less flat
- More realistic atmospheric glow

## Performance Targets

- WebGPU compute: < 5ms (smaller texture)
- WebGL2 render: < 10ms
- Total both LUTs: < 30ms (acceptable for initialization)

## Integration

Called automatically in `AtmosphericScatteringLUT.compute()`, which is called during `Frontend.initialize()`.

## Test Criteria

### Console Checks
- [ ] Log: `"Multi-scattering LUT created: 32x32"`
- [ ] Log: `"Multi-scatter computation complete"`
- [ ] No shader compilation errors

### Functional
- [ ] 32×32 RGBA16F texture created
- [ ] Computation executes without errors
- [ ] Sample random pixel: value in [0.0, 0.5] range
- [ ] Both backends produce similar results

### Visual (Comparison)
Take two screenshots:
- [ ] WITHOUT multi-scatter: Darker, flatter sky
- [ ] WITH multi-scatter: ~10-20% brighter, richer colors
- Difference should be subtle but visible

### Performance
- [ ] Multi-scatter compute < 10ms
- [ ] Total LUT generation (transmit + multi) < 50ms
- [ ] No FPS impact (done during init)

## Debug Commands
```javascript
window.testMultiScatter = async () => {
    console.log('=== Testing Multi-Scatter ===');
    
    // Disable multi-scatter
    window.frontend.useMultiScatter = false;
    await window.frontend.render();
    console.log('Rendered without multi-scatter');
    
    // Enable multi-scatter
    window.frontend.useMultiScatter = true;
    await window.frontend.render();
    console.log('Rendered with multi-scatter');
    
    console.log('Compare screenshots - should be brighter with multi-scatter');
};
```

## Common Issues

**Issue:** No visible difference
- Check multi-scatter LUT is being sampled in aerial perspective (step 3.1)
- Verify contribution weight (try 0.1x - 0.3x multiplier)
- Debug visualize the multi-scatter LUT directly

**Issue:** Too bright
- Reduce multi-scatter contribution multiplier
- Check phase functions not double-counting scattering

**Issue:** Texture is all zeros
- Verify transmittanceLUT is bound correctly as input
- Check sampling coordinates are valid
- Verify scattering coefficients are non-zero

## Next Step
After passing tests, proceed to: **2.4-lut-regeneration.md**