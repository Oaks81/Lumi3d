# 2.4: LUT Regeneration

## Dependencies
- 2.1: Transmittance LUT Resources ✓
- 2.2: Transmittance Computation ✓
- 2.3: Multi-Scattering LUT ✓

## Scope
Implement dirty flag system to regenerate LUTs when planet parameters change. Essential for supporting multiple planets with different atmospheres.

## Current State
- LUTs are computed once during initialization
- No change detection or regeneration yet
- Switching planets would not update atmosphere

## Architecture Integration
```
Frontend.render() [every frame]
  └─> AtmosphericScatteringLUT.compute()
        ├─> Check needsRecompute()
        │     ├─> Compare current vs new settings
        │     └─> Check isDirty flag
        ├─> If needed: recompute both LUTs
        └─> If not: return immediately (no work)

Planet Switch:
Frontend.switchPlanet()
  └─> AtmosphericScatteringLUT.invalidate()
        └─> Set isDirty = true
```

## What Needs to Happen

### 1. Add Dirty Flag Management to AtmosphericScatteringLUT

Properties to add:
- `isDirty: boolean` - Set when parameters change
- `isComputed: boolean` - Set after successful computation
- `currentSettings: object` - Copy of last used settings
- `lastComputeTime: number` - For performance monitoring

Methods to add:
- `needsRecompute(atmosphereSettings)` - Check if recompute needed
- `settingsEqual(settingsA, settingsB)` - Deep compare settings
- `invalidate()` - Mark dirty externally
- `cloneSettings(settings)` - Deep copy for comparison

### 2. Update compute() Method

Should now:
```javascript
async compute(atmosphereSettings) {
    // Early exit if no work needed
    if (!this.needsRecompute(atmosphereSettings)) {
        return;
    }
    
    console.log('Atmosphere dirty, regenerating LUTs');
    
    // Compute both LUTs
    // ... existing computation code ...
    
    // Update state
    this.isComputed = true;
    this.isDirty = false;
    this.currentSettings = this.cloneSettings(atmosphereSettings);
    this.lastComputeTime = elapsed;
    
    console.log(`LUTs regenerated in ${elapsed}ms`);
}
```

### 3. Settings Comparison Logic

Compare these parameters to detect changes:
- `planetRadius`
- `atmosphereRadius`
- `rayleighScattering` (r, g, b)
- `mieScattering`
- `mieAnisotropy`
- `scaleHeightRayleigh`
- `scaleHeightMie`

Ignore minor floating-point differences (epsilon comparison).

### 4. Add Planet Presets to PlanetAtmosphereSettings

Extend with presets:

**Mars:**
- Thinner atmosphere, CO₂ dominated
- Reddish scattering
- Lower density, larger scale heights

**Venus:**
- Very thick atmosphere
- High mie scattering (haze)
- Yellowish tint

**Earth:**
- Default (already defined)
- Blue Rayleigh scattering

### 5. Frontend Integration

In `Frontend.render()`:
```javascript
async render(gameState, environmentState, deltaTime) {
    // Call compute every frame - it will early-exit if not dirty
    await this.atmosphereLUT.compute(this.atmosphereSettings);
    
    // Rest of rendering...
}
```

Add planet switching method:
```javascript
switchPlanet(planetConfig) {
    this.atmosphereSettings = PlanetAtmosphereSettings.createForPlanet(planetConfig);
    this.atmosphereLUT.invalidate();
}

switchPlanetPreset(presetName) {
    this.atmosphereSettings = PlanetAtmosphereSettings.createPreset(presetName);
    this.atmosphereLUT.invalidate();
}
```

## Files to Modify

- `js/atmosphere/AtmosphericScatteringLUT.js` - Add dirty flag system
- `js/atmosphere/PlanetAtmosphereSettings.js` - Add planet presets
- `js/rendering/Frontend.js` - Call compute() in render loop, add planet switching

## Settings Comparison Strategy
```javascript
settingsEqual(a, b) {
    // Compare primitives
    if (a.planetRadius !== b.planetRadius) return false;
    if (a.atmosphereRadius !== b.atmosphereRadius) return false;
    
    // Compare vec3 (with epsilon for floats)
    const epsilon = 1e-10;
    if (Math.abs(a.rayleighScattering.r - b.rayleighScattering.r) > epsilon) return false;
    if (Math.abs(a.rayleighScattering.g - b.rayleighScattering.g) > epsilon) return false;
    if (Math.abs(a.rayleighScattering.b - b.rayleighScattering.b) > epsilon) return false;
    
    // ... etc for other parameters
    
    return true;
}
```

## Preset Examples

### Mars Atmosphere
```javascript
case 'mars':
    settings.planetRadius = 3389500;
    settings.atmosphereRadius = 3489500;  // 100km atmosphere
    settings.rayleighScattering = {
        r: 19.918e-6,  // Reddish
        g: 13.57e-6,
        b: 5.75e-6
    };
    settings.mieScattering = 1e-6;  // Very thin
    settings.scaleHeightRayleigh = 11100;
    settings.scaleHeightMie = 1500;
```

### Venus Atmosphere
```javascript
case 'venus':
    settings.planetRadius = 6051800;
    settings.atmosphereRadius = 6251800;  // 200km atmosphere
    settings.rayleighScattering = {
        r: 11.0e-6,   // Yellowish
        g: 26.0e-6,
        b: 44.0e-6
    };
    settings.mieScattering = 210e-6;  // Very thick haze
    settings.scaleHeightRayleigh = 15900;
    settings.scaleHeightMie = 3000;
    settings.mieAnisotropy = 0.9;  // Strong forward scattering
```

## Test Criteria

### Console Checks
- [ ] On planet switch: Log `"Atmosphere dirty, regenerating LUTs"`
- [ ] After regen: Log `"LUTs regenerated in {X}ms"`
- [ ] No regeneration when unchanged: No logs during normal frames

### Functional
- [ ] Changing planet parameters marks LUTs dirty
- [ ] Next frame triggers regeneration
- [ ] After regen, dirty flag clears
- [ ] Switching to same planet twice: no second regen
- [ ] Manual `invalidate()` triggers regen
- [ ] Settings comparison works correctly (epsilon comparison)

### Performance
- [ ] Regeneration doesn't cause frame stutter
- [ ] First frame after switch may drop to 55fps (acceptable)
- [ ] Returns to 60fps within 2-3 frames
- [ ] Early-exit when not dirty: < 0.01ms overhead

### Visual
Test planet switching:
- [ ] Earth: Blue sky, normal atmosphere
- [ ] Mars: Orange/red tinted, thinner atmosphere
- [ ] Venus: Thick yellowish haze
- [ ] Switch back to Earth: Returns to blue

## Debug Commands
```javascript
window.testPlanetSwitch = () => {
    console.log('=== Planet Switch Test ===');
    
    const switchTo = (name, delay) => {
        setTimeout(() => {
            window.frontend.switchPlanetPreset(name);
            window.gameEngine.render();
            console.log(`Switched to ${name}`);
        }, delay);
    };
    
    switchTo('earth', 0);
    switchTo('mars', 2000);
    switchTo('venus', 4000);
    switchTo('earth', 6000);
};

window.testNoRegeneration = () => {
    let regenCount = 0;
    
    const originalCompute = window.frontend.atmosphereLUT.compute.bind(
        window.frontend.atmosphereLUT
    );
    
    window.frontend.atmosphereLUT.compute = async function(...args) {
        if (this.isDirty) {
            regenCount++;
            console.log(`Regeneration #${regenCount}`);
        }
        return await originalCompute(...args);
    };
    
    // Render 10 frames
    for (let i = 0; i < 10; i++) {
        window.gameEngine.render();
    }
    
    console.log(`Total regenerations: ${regenCount} (should be 0)`);
};
```

## Common Issues

**Issue:** LUTs regenerate every frame
- Check `needsRecompute()` logic
- Verify `currentSettings` is being saved
- Check settings comparison for float precision issues

**Issue:** LUTs don't regenerate on planet switch
- Verify `invalidate()` is being called
- Check `isDirty` flag is set to true
- Ensure `compute()` checks dirty flag

**Issue:** Settings comparison always returns false
- Check epsilon value not too strict
- Verify deep copy of nested objects (rayleighScattering)
- Log both settings to compare

**Issue:** Frame stutter during regeneration
- Normal for first frame after switch (acceptable)
- If persistent: Check if regenerating multiple times
- Consider async/deferred regeneration if needed

## Next Step
After passing all tests, proceed to: **3.1-aerial-perspective-integration.md**