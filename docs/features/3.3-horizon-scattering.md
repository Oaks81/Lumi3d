# 3.3: Horizon Scattering

## Dependencies
- 2.1-2.4: Complete transmittance and multi-scatter LUTs âœ“
- 3.1: Aerial Perspective Integration âœ“
- Backend rendering system

## Scope
Implement atmospheric scattering for sky pixels where rays don't hit terrain. Creates realistic sky gradients from horizon to zenith, with proper sun scattering and altitude-dependent darkness.

## Current State
- Sky may render as black or use simple gradient
- LUTs are available for sampling
- Backend can render fullscreen passes

## Architecture Integration
```
Frontend.render()
  â”œâ”€> Clear buffers
  â”œâ”€> Render sky (this step) - BACKGROUND
  â”‚     â””â”€> SkyRenderer.render()
  â”‚           â””â”€> Backend renders fullscreen quad with sky shader
  â”œâ”€> Render terrain - FOREGROUND (writes depth, occludes sky)
  â””â”€> Rest of rendering...
```

## What Needs to Happen

### 1. Create SkyRenderer Class

Location: `js/atmosphere/SkyRenderer.js`

Responsibilities:
- Manage sky rendering pipeline/material
- Render fullscreen quad with sky shader
- Sample transmittance and multi-scatter LUTs
- Ray march through atmosphere for sky color

Should store:
- Sky material/pipeline reference
- Fullscreen quad geometry
- Quality settings (ray march samples)

### 2. Implement Backend Sky Rendering Methods

#### In WebGPUBackend
Add method: `renderSky(camera, atmosphereSettings, sunDir, transmittanceLUT, multiScatterLUT)`

Should:
- Use render pipeline with sky shader
- Bind LUTs as textures
- Set uniforms (camera, sun, atmosphere)
- Draw fullscreen triangle/quad
- No depth write (sky is background)

#### In WebGL2Backend
Add method: `renderSky(camera, atmosphereSettings, sunDir, transmittanceLUT, multiScatterLUT)`

Should:
- Use shader program with sky fragment shader
- Bind LUTs to texture units
- Set uniforms
- Draw fullscreen quad
- Depth test: ALWAYS or LEQUAL with depth=1.0

### 3. Create Sky Shaders

#### WebGPU: `shaders/webgpu/skyView.wgsl`

Vertex shader:
- Fullscreen triangle (no input geometry needed)
- Output clip-space position and UV

Fragment shader:
- Reconstruct world-space ray direction from UV + inverse view-projection
- Check if ray hits planet (if yes, return black - terrain will render)
- Ray march through atmosphere (16-32 samples)
- Accumulate inscatter toward sun
- Apply transmittance
- Add multi-scatter contribution
- Fade to black at high altitude

#### WebGL2: `shaders/webgl2/skyView.glsl`

Similar to WebGPU version with GLSL syntax.

### 4. Fullscreen Quad/Triangle

The sky needs to render a fullscreen primitive. Two options:

**Option A: Fullscreen Triangle (efficient)**
- Single triangle covering entire viewport
- Vertices: (-1,-1), (3,-1), (-1,3)
- No index buffer needed

**Option B: Fullscreen Quad**
- Four corners: (-1,-1), (1,-1), (1,1), (-1,1)
- Six indices: 0,1,2, 0,2,3

Create in SkyRenderer or use existing fullscreen quad if available.

### 5. Integration in Frontend

In `Frontend.initialize()`:
```javascript
this.skyRenderer = new SkyRenderer(this.backend, this.atmosphereLUT);
await this.skyRenderer.initialize();
```

In `Frontend.render()`:
```javascript
// Clear before rendering
this.backend.clear(true, true, false);

// 1. Render sky FIRST (background)
const sunDir = this.calculateSunDirection(environmentState);
this.skyRenderer.render(
    this.camera,
    this.atmosphereSettings,
    sunDir
);

// 2. Render terrain (writes depth, occludes sky)
this.renderTerrain();

// 3. Rest of rendering...
```

### 6. Ray Direction Reconstruction

In sky shader, reconstruct ray from screen UV:
```wgsl
fn getRayDirection(uv: vec2<f32>, invViewProj: mat4x4<f32>, cameraPos: vec3<f32>) -> vec3<f32> {
    // NDC coordinates
    let ndc = vec4<f32>(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, 1.0, 1.0);
    
    // World position
    var worldPos = invViewProj * ndc;
    worldPos /= worldPos.w;
    
    // Ray direction
    return normalize(worldPos.xyz - cameraPos);
}
```

Need to pass inverse view-projection matrix as uniform.

## Algorithm Overview

For each pixel:

1. **Reconstruct ray direction** from screen UV
2. **Check planet intersection:**
   - If ray hits planet â†’ return black (terrain will render)
   - If no planet hit â†’ continue to sky
3. **Check atmosphere intersection:**
   - Find where ray enters/exits atmosphere sphere
4. **Ray march through atmosphere** (16-32 steps):
   - Sample density at each step (Rayleigh + Mie)
   - Sample transmittance from LUT (sun to sample point)
   - Compute phase function (view-to-sun angle)
   - Accumulate inscatter
   - Update transmittance along view ray
5. **Add multi-scatter** contribution
6. **Fade to black** at high altitude (smoothstep 15km-50km)

## Key Formulas

### Ray-Sphere Intersection
```
origin + t * direction = point on sphere
Solve: |origin + t * dir|Â² = radiusÂ²
Returns: (t_near, t_far)
```

### Inscatter Along Ray
```
L += transmittance_view * scattering * phase * sunTransmittance * dt
transmittance_view *= exp(-extinction * dt)
```

### Phase Functions
- Rayleigh: `(3/16Ï€) * (1 + cosÂ²Î¸)`
- Mie: `(1/4Ï€) * (1-gÂ²) / (1 + gÂ² - 2g*cosÎ¸)^(3/2)`

### Altitude Fade
```
fade = smoothstep(15000, 50000, viewerAltitude)
skyColor *= (1 - fade)
```

## Shader Inputs (Uniforms)

Both backends need:
- Camera: position, inverse view-projection matrix
- Sun: direction (normalized)
- Atmosphere: all parameters (planet radius, scattering coefficients, etc.)
- LUTs: transmittance and multi-scatter textures + samplers

## Files to Create

- `js/atmosphere/SkyRenderer.js`
- `js/rendering/shaders/webgpu/skyView.wgsl`
- `js/rendering/shaders/webgl2/skyView.glsl`

## Files to Modify

- `js/rendering/Frontend.js` - Add sky rendering pass
- `js/rendering/backends/WebGPUBackend.js` - Add `renderSky()` method
- `js/rendering/backends/WebGL2Backend.js` - Add `renderSky()` method

## Expected Visual Result

At different altitudes and view angles:

**Surface level (100m):**
- Looking up (zenith): Dark blue sky
- Looking at horizon: Light blue gradient
- Toward sun: Brighter, yellow-ish tint

**Mid altitude (5km):**
- Zenith: Darker blue (approaching black)
- Horizon: Blue with gradient to light
- Sky less bright overall

**High altitude (15km+):**
- Zenith: Nearly black
- Horizon: Thin bright line (atmospheric limb)
- Space-like darkness

**Sun position matters:**
- Sunrise/sunset: Orange/red horizon
- Midday: Deep blue zenith, lighter horizon

## Performance Targets

- Sky render: < 2ms full screen
- Ray march: 16-32 samples sufficient
- No overdraw (terrain occludes sky with depth test)

## Test Criteria

### Visual
- [ ] Sky shows gradient from horizon to zenith
- [ ] Horizon is bright, zenith is dark (at surface)
- [ ] At high altitude (15km+): Sky mostly black
- [ ] Sun direction affects color (blue away, orange toward)
- [ ] Sunrise/sunset shows orange/red colors
- [ ] Sky doesn't render where terrain exists

### Console Checks
- [ ] Log: `"Sky renderer initialized"`
- [ ] No shader compilation errors
- [ ] No NaN/Infinity in shader output

### Functional
- [ ] Ray-planet intersection prevents sky where terrain is
- [ ] Ray marching executes without errors
- [ ] Transmittance LUT sampled correctly
- [ ] Multi-scatter contribution added
- [ ] Altitude fade works (darkens at high altitude)

### Performance
- [ ] Sky render < 2ms
- [ ] 16-32 samples sufficient quality
- [ ] No significant overdraw

## Debug Commands
```javascript
window.testSky = () => {
    const scenarios = [
        { alt: 100, pitch: 0, name: 'Surface looking up' },
        { alt: 100, pitch: 90, name: 'Surface at horizon' },
        { alt: 5000, pitch: 0, name: 'High altitude up' },
        { alt: 15000, pitch: 0, name: 'Very high altitude' }
    ];
    
    scenarios.forEach(s => {
        window.camera.position.z = s.alt;
        window.camera.setPitch(s.pitch);
        window.gameEngine.render();
        console.log(s.name);
    });
};

window.toggleSky = () => {
    window.frontend.skyRenderer.enabled = !window.frontend.skyRenderer.enabled;
    console.log(`Sky: ${window.frontend.skyRenderer.enabled}`);
};

window.setSkyQuality = (samples) => {
    window.frontend.skyRenderer.numSamples = samples;
    console.log(`Sky samples: ${samples}`);
};
```

## Common Issues

**Issue:** Sky is all black
- Check ray-atmosphere intersection
- Verify scattering coefficients not zero
- Check transmittance LUT is bound
- Verify sun direction normalized

**Issue:** Sky all white/overexposed
- Reduce scattering coefficients by 0.5x
- Check sun transmittance not > 1.0
- Verify phase functions normalized

**Issue:** Sky renders on top of terrain
- Check depth test enabled
- Verify render order (sky before terrain)
- Ensure terrain writes depth values

**Issue:** Seam at horizon
- Increase ray march samples
- Blend sky with terrain inscatter
- Check depth precision

**Issue:** No altitude fade
- Verify viewer altitude uniform updating
- Check smoothstep range (15km-50km)
- Ensure fade multiplier applied

## Performance Optimization

For lower-end hardware:
```javascript
// Reduce samples
this.skyRenderer.numSamples = 8;

// Half resolution
this.skyRenderer.renderScale = 0.5;

// Skip at very low altitudes
if (camera.altitude > 100) {
    this.skyRenderer.render(...);
}
```

## Completion Milestone

After **3.3 passes**, you have completed:
- âœ… **Phase 2:** Transmittance & Multi-scatter LUTs
- âœ… **Phase 3:** Aerial Perspective complete

**Sky renderer gives you:**
- Realistic atmospheric sky
- Altitude-dependent darkness
- Sun scattering effects
- Foundation for cloud rendering (Phase 5)

**Next phases:**
- **Phase 4:** Froxel volumetric system (WebGPU clouds)
- **Phase 6:** Planar cloud fallback (WebGL2)

Congratulations! ðŸŽ‰

## Next Steps

Consider:
1. Test full system at various altitudes (0m - 20km)
2. Test different times of day (sunrise, noon, sunset)
3. Test planet switching (Earth, Mars, Venus)
4. Performance profiling across both backends
5. Screenshot comparisons for visual validation

Then proceed to cloud rendering phases or other features!